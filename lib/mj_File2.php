<?php

/**
 * This class basically handles access for files. It generates names, paths and urls. 
 * It will pull in metadata for files referenced by ID.
 */

require_once("mj_File2BaseValues.php");
require_once("mj_File2Upload.php");
require_once("mj_File2MetaDb.php");
require_once("mj_File2MetaText.php");
require_once("mj_File2Image.php");
require_once("mj_File2Exif.php");

class mj_File2 extends mj_File2BaseValues
{
  public    $id   = 0;
  protected $cfg  = NULL;
  protected $err  = NULL;
  protected $meta = NULL;
  protected $metaWriterClass = "mj_File2MetaDb";

  protected $mime   = NULL; // actual mime type retrieved from the image
  protected $type   = NULL; // type as something we can deal with easily in code png|jpg|bmp|gif

  static $errors = array();

  const URL_FULL     = 1; // includes domain 
  const URL_LOCAL    = 2; // from docroot starting with /
  const URL_RELATIVE = 3; // relative to current exective - does not start with a /

  static private function _getData(&$data,$default=false) 
  { 
    if (isset($data))
      return $data;
    else 
      return $default; 
  }

  ////////////////////////////////////////////////////////////////////////////////
  /// functions
  ////////////////////////////////////////////////////////////////////////////////

  function __construct($cfg=NULL, $id=0)
  {
    $LINE = 0;
    try
    {
      if ($id > 0) $this->id  = $id;

      $this->cfg = (isset($cfg) && is_array($cfg)) ? $cfg : self::setDefaultConfig();

      if ($this->meta === NULL && $id > 0) 
      {
        if ($this->fetchMeta($id) === false)
         { $LINE = __LINE__; throw new Exception("Failed to load file meta data"); }
      }

      //parent::__construct();
    }
    catch (Exception $e)
    {
      mjlog(NOTICE,__METHOD__,"Exception caught: ".$e->getMessage(),$LINE);
      throw new Exception("Failed to load file meta data for fid[$id]"); 
    }
  }

  /**
   * this function allows you not to have to pass in the controls every time an image is instantiated.
   */
  public function setConfig($cfg)
  {
    $this->cfg = $cfg;
  }

  public function setMeta($meta)
  {
    $this->meta = $meta;
  }

  /**
   * returns the last error generated by the class
   */
  public function getErr()
  {
    return $this->err;
  }

  ////////////////////////////////////////////////////////////////////////////////
  /// functions for getting objsct data
  ////////////////////////////////////////////////////////////////////////////////

  public function getId()                  { return @self::_getData($this->id);           }
  public function getName()                { return @self::_getData($this->meta['name']); }
  public function getExtension()           { return @self::_getData($this->meta['ext']);  }
  public function getPath()                { return @self::_getData($this->meta['dirPath']); }
  public function getUrlPath()             { return @self::_getData($this->meta['urlPath']); }
  public function getOriginalName()        { return @self::_getData($this->meta['extra']['origFileName']);  }
  public function getFormFieldName()       { return @self::_getData($this->meta['extra']['formFieldName']); }
  public function getMimeType()            { return @self::_getData($this->meta['mimeType']);              }
  public function getFileType()            { return @self::_getData($this->meta['type']); }
  public function getFullPathAndFileName() { return @self::pathPartsJoin(array(MJ_ROOT_PATH,self::_getData($this->meta['dirPath']),self::_getData($this->meta['name']))); }

  public function getMeta()                { return $this->meta; }
  public function getImageMeta()           { return self::_getData($this->meta['meta']['cfg']['image'],false); }
  public function getExif()                { return self::_getData($this->meta['meta']['exif'],false); }
  public function getImgCfg()              
  { 
    //mjlog(DEBUG,__METHOD__,"meta: ". print_r($this->meta,true),__LINE__);
    //mjlog(DEBUG,__METHOD__,"meta['cfg']['image']['sizes']: ". print_r($this->meta['meta']['cfg']['image']['sizes'],true),__LINE__);

    $sizes = self::_getData($this->meta['cfg']['image']['sizes'],false); 
    if ($sizes === false)
      $sizes = self::_getData($this->meta['meta']['cfg']['image']['sizes'],false); 
    return $sizes;
  }
  public function getLatLon()              
  { 
    //mjlog(DEBUG,__METHOD__,"meta: ".            print_r($this->meta,true),__LINE__);
    //mjlog(DEBUG,__METHOD__,"meta[exif]: ".      print_r($this->meta['meta']['exif'],true),__LINE__);
    //mjlog(DEBUG,__METHOD__,"meta[exif][GPS]: ". print_r($this->meta['meta']['exif']['GPS'],true),__LINE__);
    $geo = self::_getData($this->meta['meta']['exif']['GPS'],false);
    if ($geo === false)
      $geo = self::_getData($this->meta['exif']['GPS'],false);
    if ($geo !== false)
    {
      $latlon = array('lat' => $geo['Latitude'],'lon' => $geo['Longitude']);  
      return $latlon;
    }
    return false;
  }

  public function getFileContents() { return file_get_contents($this->getFullName()); }

  public function copyFile($toName) {}
  public function writeFile($name,$contents) {}
  public function deleteFile() {}

  public function isResizeableImage() { return in_array($this->meta['type'],mj_File2BaseValues::$rezeable); }

  ////////////////////////////////////////////////////////////////////////////////
  /// misc file functions
  ////////////////////////////////////////////////////////////////////////////////

  /**
   * return only the extension from the filename
   */
  static public function parseExtension($fname)
  {
    $idx = strrpos($fname,".");
    if (!$idx) return ""; 
    $len = strlen($fname) - $idx;
    $ext = substr($fname,$idx+1,$len);
    return strtolower($ext);
  }

  /**
   * return the complete path and filename minus the extension
   */
  static public function removeExtension($fname)
  {
    $idx = strrpos($fname,".");
    if (!$idx) return ""; 

    $len  = strlen($fname) - $idx;
    $name = substr($fname,0,$len);

    return $name;
  }

  /**
   * return the complete path and filename minus the extension
   */
  static public function splitNameAndExtension($fname)
  {
    $idx = strrpos($fname,".");
    if (!$idx) return array(false,false);

    $len  = strlen($fname) - $idx;
    $ext  = substr($fname,$idx+1,$len);
    $name = substr($fname,0,$idx);

    return array($name,$ext);
  }

  /**
   * return the complete path and filename minus the extension
   */
  static public function splitPathAndName($fname)
  {
    $idx = strrpos($fname,'/');
    if (!$idx) return array(false,false);

    $len  = strlen($fname) - $idx;
    $name = substr($fname,$idx+1,$len);
    $path = substr($fname,0,$idx);

    return array($path,$name);
  }

  /**
   *
   */
  public function filesizeString($filesize)
  {
    if (is_numeric($filesize))
    {
      $decr = 1024; $step = 0;
      $prefix = array('Byte','KB','MB','GB','TB','PB');

      while (($filesize / $decr) > 0.9)
      {
        $filesize = $filesize / $decr;
        $step++;
      }
      return round($filesize,2).' '.$prefix[$step];
    }
    else return 'NaN';
  }

  /**
   * cleanely joins together an array of path parts.
   * can be used for both URL's and directory paths.
   */
  public static function pathPartsJoin($parts,$stripLeadingSlash=false)
  {
    $rez = '';
    for ($ii=0; $ii < count($parts); $ii++) // http://shotspotz.localhost/example2.upload.php
    {
      if ($ii == 0)
      {
        if ($parts[$ii] != 'http://' && $parts[$ii] != 'https://')
        {
          // make sure there is not a trailing slash
          if (substr($parts[$ii],-1,1) == '/') $parts[$ii] = substr($parts[$ii],0,(strlen($parts[$ii])-1));

          // add leading slash
          if (substr($parts[$ii],0,1) != '/' && $stripLeadingSlash == false) $parts[$ii] = '/'. $parts[$ii];
        }
      }
      else
      {
        // add leading slash
        if (substr($parts[$ii],0,1) != '/') $parts[$ii] = '/'. $parts[$ii];
        // make sure there is not a trailing slash
        if (substr($parts[$ii],-1,1) == '/') $parts[$ii] = substr($parts[$ii],0,(strlen($parts[$ii])-1));
      }
    }
    $rez = implode('',$parts);
    return $rez;
  }

  ////////////////////////////////////////////////////////////////////////////////
  /// file PATH functions
  ////////////////////////////////////////////////////////////////////////////////

  /**
   * build the relative path to the new file. Returns a value to be user by both the physical path and the url path
   */
  function generatePath($newFileName)
  {
    //mjlog(DEBUG,__METHOD__,"this->cfg['dir']['tree']: ". print_r($this->cfg,true));
    $path = '';
    $naming = $this->cfg['dir']['tree'];
    //mjlog(DEBUG,__METHOD__,"naming[$naming] cfg: ". print_r($this->cfg,true),__LINE__);

    if (array_key_exists($naming,self::$_pathFuncs))
    {
      $func = self::$_pathFuncs[$naming];
      $path = $this->$func($newFileName);
      mjlog(DEBUG,__METHOD__,"func[$func] new path[$path]",__LINE__);
    }
    else if (substr($naming,0,5) == 'func|') // check naming[func|LocationJs::nameTempFile] 
    {
        list($cmd,$func) = explode('|',$naming);
        if (strpos($func,'::') > 0)
        {
          list($class,$meth) = explode('::',$func);
          if (!method_exists($class,$meth))
          {
            mjlog(ERROR,__METHOD__,"Invalid naming function configured: naming[$naming] class[$class] method[$meth]",__LINE__);
            if ($class_exists($class))
              mjlog(ERROR,__METHOD__,"Invalid naming function configured: no class defined class[$class]",__LINE__);
            return false;
          }
        }
        elseif (!function_exists($str))
        {
          mjlog(ERROR,__METHOD__,"Invalid naming function configured: $naming",__LINE__);
          return false;
        }
        $path = call_user_func($func,$newFileName,$this);
    }
    else mjlog(ERROR,__METHOD__,"Invalid naming function configured",__LINE__);

    //$this->checkPath($this->cfg['dir']['basePath'] .'/ht/'. $path);
    return $path . ($path == '' ? '' : '/');
  }

  protected function generateRandomString($length=4)
  {
    $characters = "0123456789abcdefghijklmnopqrstuvwxyz";
    $maxrand    = strlen($characters) -1;
    $name       = '';
    for ($ii = 0; $ii < $length; $ii++)
      $name .= $characters[mt_rand(0,$maxrand)];
    mjlog(DEBUG,__METHOD__,"generated rand name[$name]");
    return $name;
  }

  /**
   * calculate a path based on current userID and file id
   */
  function generatePathUidFid($newFileName)
  {
    $path = sprintf("%07d/%07d",mj_User::$currUser->id,$this->id);
    return $path;    
  }

  /**
   * calculate a path based on current userID and file id
   */
  function generatePathUid($newFileName)
  {
    $path = sprintf("%05d",mj_User::$currUser->id);
    return $path;
  }

  /**
   * calculate the path from the filename, cheaper to call than checkPath
   * basically the first n letters will be used to create a path to the file
   *
   * @param string $name code file name only. name will be used to build a path string
   * @param int $depth number of dir levels to build
   *
   * @return string the calculated path ending with a "/"
   */
  function generatePathByNameChars($name, $depth=0)
  {
    mjlog(DEBUG,__CLASS__."::".__FUNCTION__,"name[$name] depth[$depth]");
    if ($depth == 0)
      $depth = (isset($this->cfg['dir']['depth'])) ? $this->cfg['dir']['depth'] : 4;  // default of 4 if not set anywhere else

    $path = "";
    for ($ii=0; $ii < $depth; $ii++)
    {
      $path .= $name[$ii].'/';
    }
    return $path;
  }

  /**
   * check the path from the filename and make sure all the dirs exist in the calc'd path
   * it will also return the path that it checked
   *
   * @param string $name base part of the file name
   * @param int $depth number of dir levels to create, when 0 a default value of 4 is used
   *
   * @return string|false returns the partial path or false on error
   */
  function checkPath($testPath)
  {
    mjlog(DEBUG,__METHOD__,"testPath[$testPath]",__LINE__);

    $fpath = '';
    //$fpath = substr(MJ_ROOT_PATH,0,(strlen(MJ_ROOT_PATH)-1));
    //mjlog(DEBUG,__METHOD__,"fpath[$fpath] testPath[$testPath]",__LINE__);
    $parts = explode('/',trim($testPath));
    foreach ($parts as $dirname)
    {
      if (trim($dirname) == '') continue;
      $fpath .=  '/'. $dirname;
      mjlog(DEBUG,__METHOD__,"checking fpath[$fpath]",__LINE__);
      if (!file_exists($fpath))
      {
        if (mkdir($fpath) === false)
        {
          mjlog(ERROR,__METHOD__,"failed to create path[$fpath]",__LINE__);
          return false;
        }
      }
    }
    mjlog(DEBUG,__METHOD__,"successfully created fpath[$fpath] - returning",__LINE__);
    return $fpath;
  }

  ////////////////////////////////////////////////////////////////////////////////
  /// File NAME functions
  ////////////////////////////////////////////////////////////////////////////////

/*
  static protected $_nameFuncs = array(
    'rand'    => 'genRandomFileName',
    'ms5'     => 'genMd5FileName',
    'tmpname' => 'genTmpnameFileName',
    'keep'    => 'genOrigFileName'
    'func|'   = name of other, random function or method. methods must be static and written as className::methodName
  );
*/
  /**
   * Used on initial import to build a new filename 
   */
  function generateNewFileName($origName)
  {
    list($name,$ext) = self::splitNameAndExtension($origName);
    $ext = strtolower($ext);
    $newName = $name;

    $naming = $this->cfg['file']['naming'];
    mjlog(DEBUG,__METHOD__,"origName[$origName] name[$name] ext[$ext] naming[$naming] cfg: ". print_r($this->cfg,true),__LINE__);

    if (array_key_exists($naming,self::$_nameFuncs))
    {
      $func = self::$_nameFuncs[$naming];
      mjlog(DEBUG,__METHOD__,"about to call naming func[$func] name[$name]",__LINE__);
      $newName = $this->$func($name);
      mjlog(DEBUG,__METHOD__,"func[$func] newName[$newName]",__LINE__);
    }
    else if (substr($naming,0,5) == 'func|') // check naming[func|LocationJs::nameTempFile] 
    {
        list($cmd,$func) = explode('|',$naming);
	if (strpos($func,'::') > 0)
	{
	  list($class,$meth) = explode('::',$func);
	  if (!method_exists($class,$meth))
	  {
	    mjlog(ERROR,__METHOD__,"Invalid naming function configured: naming[$naming] class[$class] method[$meth]",__LINE__);
	    if ($class_exists($class))
	      mjlog(ERROR,__METHOD__,"Invalid naming function configured: no class defined class[$class]",__LINE__);
	    return false;
	  }
	}
	elseif (!function_exists($str))
	{
	  mjlog(ERROR,__METHOD__,"Invalid naming function configured: $naming",__LINE__);
	  return false;
	}
        mjlog(DEBUG,__METHOD__,"about to call 'call_user_func' func[$func] newName[$newName]",__LINE__);
        $newName = call_user_func($func,$name,$this);
    }
    else mjlog(ERROR,__METHOD__,"Invalid naming function configured",__LINE__);

    return $newName .'.'. strtolower($ext);  
  }

  protected function genTmpnameFileName($name) { return tempnam($dir='',$prefix=''); }
  protected function genOrigFileName($name)    { return $name; }
  protected function genFidFileName($name)     { return $this->id; }

  /**
   * generate a file name based on a hash of the files's contents
   *
   * @return string name-only part of a new file name (no extension, no path)
   */
  protected function generateMd5FileName()
  {
    $oldfilename = $this->tmpFileName;
    $handle = fopen($oldfilename, "rb");
    $contents = fread($handle, filesize($oldfilename));
    fclose($handle);
    $filemd5 = md5($contents);
    mjlog(DEBUG,__METHOD__,"filemd5 name[$filemd5]");
    return $filemd5;
  }

  /**
   * generate a file name based on random character selection 
   *
   * @return string name-only part of a new file name (no extension, no path)
   */
  protected function generateRandomFileName()
  {
    $length     = isset($this->cfg['nameLen']) ? $this->cfg['nameLen'] : 10;
    $characters = "0123456789abcdefghijklmnopqrstuvwxyz";
    $maxrand    = strlen($characters) -1;
    $name       = '';
    for ($ii = 0; $ii < $length; $ii++)
      $name .= $characters[mt_rand(0,$maxrand)];
    mjlog(DEBUG,__METHOD__,"generated rand name[$name]");
    return $name;
  }

  /**
   * calculate the path from the filename
   */
  /*
  function getFullPathForImage($name, $base)
  {
    $path = $this->cfg['physPath'] . $this->etPath($name) . $name .'_'. $sizeDesc .'.'. $imgtype;
    return $path;
  }
  */

  ////////////////////////////////////////////////////////////////////////////////
  /// composite name/path functions
  ////////////////////////////////////////////////////////////////////////////////

  /**
   * Used on initial import to build a full, physical path and filename for accessing by code.
   * Uses the configuration and the given path and filename build the physical full path and name.
   * to use the file's store metadata in building this use getFullPathAndFileName() instead
   */
  function buildFullPathAndFileName($path,$fname)
  {
    $cfgpath = (substr(MJ_ROOT_PATH,-1) == '/' && substr($path,0,1) == '/') ? substr($path,1) : $path;
    $fullpath =  MJ_ROOT_PATH .'ht/'. $cfgpath . $fname;
    mjlog(DEBUG,__METHOD__,"MJ_ROOT_PATH[".MJ_ROOT_PATH."] path[$path] cfgpath[$cfgpath] fullpath[$fullpath]",__LINE__);
    return $fullpath;
  }

  /** 
   * construct a filename from the various parts and give it a valid extension based on its type
   */
  function buildFileName($name, $sizeStr='', $asURL=false)
  {
    $path     = $this->cfg[($asURL ? 'baseURL' : 'dirPath')] . $this->getPath($name);
    $filename = $path . $name .($sizeStr == '' ? '' : '-'). $sizeStr .".". $this->type;
    return $filename;
  }

  /**
   * this function will generate filenames for the set of images
   * it will guarantee and unique base filename
   * It does not actually save any files
   * structure: <base path|url><n-dirs><<base name>-<unique 9999>>-<size desc>.<jpg|gif|png>
   * 
   * @return string name only part guaranteed unique
   */
  function generateNewFileNames()
  {
    $this->coreFileName = NULL;
    //echo "\n<br>\nfileNaming = ".$this->cfg['fileNaming']."\n<br>\n";
    //echo "\n<br><pre>\n_nameFuncs: ".print_r($this->_nameFuncs,true)."\n</pre><br>\n";
    $func  = $this->_nameFuncs[$this->cfg['fileNaming']];
    //echo "\n<br>\nfunc: $func\n<br>\n";
    $fname = $this->$func();
    $path  = $this->cfg['dirPath'] . $this->heckPath($fname);
    mjlog(DEBUG,__CLASS__."::".__FUNCTION__,"fname[$fname] path[$path]",__LINE__);

    $funique = -1;
    do
    {
      $funique++;
      if ($funique > 1000)
      {
        mjlog(WARNING,__CLASS__."::".__FUNCTION__,"bailing out because funique > 10 ",__LINE__);
        return false;
      }
      $filename = $this->uildMetaFileName($fname,$funique);
      mjlog(DEBUG,__CLASS__."::".__FUNCTION__,"checking(2) testname[$filename]",__LINE__);
    }
    while (file_exists($filename));

    $final = $fname . ($funique > 0 ? ('-'.$funique) : '');
    $this->coreFileName = $final;
    mjlog(DEBUG,__CLASS__."::".__FUNCTION__,"final filename[$final]",__LINE__);
    return $final;
  }

  ////////////////////////////////////////////////////////////////////////////////
  /// URL functions
  ////////////////////////////////////////////////////////////////////////////////

//public function getUrl($relative=true)   { return self::_getData($this->cfg['baseURL']) . self::_getData($this->meta['name']); }
//public function getUrl($relative=true)   { return self::_getData($this->cfg['baseURL']) . $this->getPath() . self::_getData($this->meta['name']); }

//  const URL_FULL     = 1; // includes domain 
//  const URL_LOCAL    = 2; // from docroot starting with /
//  const URL_RELATIVE = 3; // relative to current exective - does not start with a /

  /**
   * build the URL of an image for embedding into a page
   * <base url><n-dirs><name>_<size desc>.<type>
   *
   * @param string $name basic name part of the image file, as used by the metafile
   * @param string $sizeDesc which named image size is intended to be used
   * @param string $imgtype image extension if known, if not given the metafile will be referenced
   *
   * @return string full URL of the image
   */
  public function getImageUrl($urlType=mj_File2::URL_LOCAL,$sizeDesc="")
  {
    //mjlog(DEBUG,__METHOD__,"urlType[$urlType] sizeDesc[$sizeDesc] cfg: ". print_r($this->cfg,true),__LINE__);
    $name = $this->getName();
    if ($sizeDesc != '')
    {
      list($name,$ext)  = $this->splitNameAndExtension($name);
      $name = $name .'.rsz.'. $sizeDesc .'.'. $ext;
    }
    $parts = array();
    if ($urlType == self::URL_FULL) $parts[] = mj_Config::getGeneralConfigValue('baseUrl','http://'.$_SERVER["HTTP_HOST"]);
    $parts[] = $this->getUrlPath();
    $parts[] = $name;

    $path = self::pathPartsJoin($parts,$stripLeadingSlash=false);
    mjlog(DEBUG,__METHOD__,"path[$path]",__LINE__);
    return $path;
  }
  public function getImageUrl2($sizeDesc="") { return $this->getImageUrl($urlType=mj_File2::URL_LOCAL,$sizeDesc); } 


  public function getImageUrls()
  {
    if (($sizes = $this->getImgCfg()) === false) return false;
    
    $urls = array();
    foreach ($sizes as $name => $cfg)
    {
      $url = $this->getImageUrl2($name);
      mjlog(DEBUG,__METHOD__,"name[$name] url[$url]",__LINE__);
      $urls[$name] = $url;
    }
    return $urls;
  }


  public function getUrl($urlType=mj_File2::URL_LOCAL,$sizeDesc="")
  {
    mjlog(DEBUG,__METHOD__,"urlType[$urlType] sizeDesc[$sizeDesc] cfg: ". print_r($this->cfg,true),__LINE__);
    if ($this->isResizeableImage() && $sizeDesc != "")
      return $this->getImageUrl($urlType,$sizeDesc);
    $parts = array();
    if ($urlType == self::URL_FULL) $parts[] = mj_Config::getGeneralConfigValue('baseUrl','http://'.$_SERVER["HTTP_HOST"]);
    $parts[] = $this->getUrlPath();
    $parts[] = $this->getName();
    $path = self::pathPartsJoin($parts,$stripLeadingSlash=false);

    mjlog(DEBUG,__METHOD__," path[$path] parts: ". print_r($parts,true),__LINE__);
    return $path;
  }
  //public function getURL_old($name, $sizeDesc, $imgtype=NULL)
  //{
  //  if (!$imgtype) $imgtype = $this->getExtension();
  //
  //  $path = $this->cfg['baseURL'] . $this->getPath($name) . $name .'-'. $sizeDesc .'.'. $imgtype;
  //  return $path;
  //}

  ////////////////////////////////////////////////////////////////////////////////
  /// metadata handling
  ////////////////////////////////////////////////////////////////////////////////

  /**
   * create the full path to the image metafile
   *
   * @params string $path physical path or url to the file
   * @params string $name name portion of the file
   * @params int $funique used only when calculating a NEW filename
   *
   * @return string the full path+filename of the image meta file
   */
  public function buildMetaFileName(&$name, $funique=NULL)
  {
    $path     = $this->cfg['dirPath'] . $this->etPath($name);
    $filename = $path . $name . ($funique > 0 ? ('-'.$funique) : '') .".meta";
    mjlog(DEBUG,__METHOD__,"filename[$filename] path[$path]",__LINE__);
    return $filename;
  }

  /**
   *
   */
  public function fetchMeta($id=0)
  {
    if ($id > 0) $this->id = $id;

    mjlog(DEBUG,__METHOD__,"id[$this->id]",__LINE__);
    if ($this->id > 0)
    {
      try
      {
        $this->meta = mj_FileMetaDb::fetchMeta($this->id);
        //mjlog(NOTICE,__METHOD__,"meta: ". print_r($this->meta,true),__LINE__);
      }
      catch (Exception $e)
      {
        $this->fetchErr = $e->getMessage();
        mjlog(NOTICE,__METHOD__,"Exception caught: ".$e->getMessage().' '.$log,__LINE__);
        return false;
      }
    }
    return true;
  }

  /**
   *
   */
  public function writeMetaData($meta=NULL)
  {
    if (isset($meta)) $this->meta = $meta;
    if (!isset($this->meta)) return;
    
    $rez = '';
    switch ($this->metaWriterClass)
    {
      default:
      case 'db':   $ez = mj_FileMetaDb::saveMeta(  $this->id,$this->meta);  break;
      case 'file': $ez = mj_FileMetaText::saveMeta($this->id,$this->meta);  break;
      case 'none': break;
    }
    return $ez;
  }

}


